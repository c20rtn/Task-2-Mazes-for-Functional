<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="dcda5aca-7c30-45ba-be1f-8963b381224e" name="Default Changelist" comment="">
      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/../client/.gitignore" beforeDir="false" afterPath="$PROJECT_DIR$/../client/.gitignore" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/../client/CHANGELOG.md" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/../client/LICENSE" beforeDir="false" afterPath="$PROJECT_DIR$/../client/LICENSE" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/../client/README.md" beforeDir="false" afterPath="$PROJECT_DIR$/../client/README.md" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/../client/client.iml" beforeDir="false" afterPath="$PROJECT_DIR$/../client/client.iml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/../client/doc/intro.md" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/../client/project.clj" beforeDir="false" afterPath="$PROJECT_DIR$/../client/project.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/../client/src/client/core.clj" beforeDir="false" afterPath="$PROJECT_DIR$/../client/src/client/core.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/../client/test/client/core_test.clj" beforeDir="false" />
    </list>
    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$/.." />
  </component>
  <component name="ProjectId" id="1XceFvHmpIcKiUpt8lkerJjCA2L" />
  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
  <component name="PropertiesComponent">
    <property name="SHARE_PROJECT_CONFIGURATION_FILES" value="true" />
    <property name="WebServerToolWindowFactoryState" value="false" />
    <property name="aspect.path.notification.shown" value="true" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$" />
    <property name="node.js.detected.package.eslint" value="true" />
    <property name="node.js.detected.package.tslint" value="true" />
    <property name="node.js.path.for.package.eslint" value="project" />
    <property name="node.js.path.for.package.tslint" value="project" />
    <property name="node.js.selected.package.eslint" value="(autodetect)" />
    <property name="node.js.selected.package.tslint" value="(autodetect)" />
    <property name="nodejs_package_manager_path" value="npm" />
    <property name="settings.editor.selected.configurable" value="preferences.general" />
  </component>
  <component name="ReplState" timestamp="1585066856695">{:repl-history {:ide [], :local [{:command &quot;(get-in maze 0)&quot;, :offset 14, :ns &quot;user&quot;} {:command &quot;(get-in maze [0])&quot;, :offset 15, :ns &quot;user&quot;} {:command &quot;(count (get-in [[{:north 0, :east 1, :south 0, :west 0}\n                 {:north 0, :east 1, :south 0, :west 1}\n                 {:north 0, :east 1, :south 0, :west 1}\n                 ]\n                [{:north 0, :east 1, :south 0, :west 0}\n                 {:north 0, :east 1, :south 0, :west 1}\n                 {:north 0, :east 1, :south 0, :west 1}\n                 ]\n                [{:north 1, :east 0, :south 0, :west 0}\n                 {:north 1, :east 0, :south 0, :west 0}\n                 {:north 1, :east 0, :south 0, :west 0}\n                 ]] [0]))&quot;, :offset 561, :ns &quot;user&quot;} {:command &quot;(loop [x 0 y 0 grid maze]\n  (when (&lt; x 4)\n    (loop [_x x _y y _grid grid]\n      (when (&lt; _y 4)\n        (print [x _y])\n        (recur _x (inc _y) grid)))\n    (println)\n    (recur (inc x) y grid)))&quot;, :offset 196, :ns &quot;user&quot;} {:command &quot;(if (&lt; 3 4)\n  (print 1)\n  (print 0))&quot;, :offset 3, :ns &quot;user&quot;} {:command &quot;(loop [x 0 y 0 grid maze]\n  (when (&lt; x 4)\n    grid\n    (recur (inc x) y (loop [_x x _y y _grid grid]\n                       (if (&lt; _y 4)\n                         _grid\n                         (recur _x (inc _y) grid))))))&quot;, :offset 219, :ns &quot;user&quot;} {:command &quot;(defn maze-row [columns]\n  (loop [count 0 row []]\n    (if (= columns count)\n      row\n      (recur (inc count) (conj row {:north 0 :east 0 :south 0 :west 0})))))\n\n(defn maze-grid [rows columns]\n  (loop [count 0 grid []]\n    (if (= rows count)\n      grid\n      (recur (inc count) (conj grid (maze-row columns))))))\n\n(maze-grid 4 4)&quot;, :offset 330, :ns &quot;user&quot;} {:command &quot;(defn maze-row [x y]\n  (loop [count 0 row []]\n    (if (= y count)\n      row\n      (recur (inc count) (conj row {:north 0 :east 0 :south 0 :west 0})))))\n\n(defn maze-grid [rows columns]\n  (loop [count 0 grid []]\n    (if (= rows count)\n      grid\n      (recur (inc count) (conj grid (maze-row count columns))))))\n\n(maze-grid 4 4)&quot;, :offset 326, :ns &quot;user&quot;} {:command &quot;(defn maze-row [x y]\n  (loop [count 0 row []]\n    (if (= y count)\n      row\n      (recur (inc count) (conj row {:north 0 :east 0 :south 0 :west 0})))))\n\n(defn maze-grid [rows columns]\n  (loop [count 0 grid []]\n    (println grid)\n    (if (= rows count)\n      grid\n      (recur (inc count) (conj grid (maze-row count columns))))))\n\n(maze-grid 3 3)&quot;, :offset 227, :ns &quot;user&quot;} {:command &quot;(defn maze-row [x y]\n  (loop [count 0 row []]\n    (if (= y count)\n      row\n      (recur (inc count) (conj row {:north 0 :east 0 :south 0 :west 0})))))\n\n(defn maze-grid [rows columns]\n  (loop [count 0 grid []]\n    (if (= rows count)\n      grid\n      (recur (inc count) (conj grid (maze-row count columns))))))\n\n(maze-grid 3 3)&quot;, :offset 232} {:command &quot;(defn maze-row [x y]\n  (loop [count 0 row []]\n    (println row)\n    (if (= y count)\n      row\n      (recur (inc count) (conj row {:north 0 :east 0 :south 0 :west 0})))))\n\n(defn maze-grid [rows columns]\n  (loop [count 0 grid []]\n    (println grid)\n    (if (= rows count)\n      grid\n      (recur (inc count) (conj grid (maze-row count columns))))))\n\n(maze-grid 3 3)&quot;, :offset 363, :ns &quot;user&quot;} {:command &quot;(defn maze-row [x y]\n  (loop [count 0 row []]\n    (println row)\n    (if (= y count)\n      row\n      (recur (inc count) (conj row {:north 0 :east 0 :south 0 :west 0})))))\n\n(defn maze-grid [rows columns]\n  (loop [count 0 grid []]\n    (if (= rows count)\n      grid\n      (recur (inc count) (conj grid (maze-row count columns))))))\n\n(maze-grid 3 3)&quot;, :offset 227, :ns &quot;user&quot;} {:command &quot;(assoc-in maze [0 0] {:north 1, :east 1, :south 1, :west 1})&quot;, :offset 60, :ns &quot;user&quot;} {:command &quot;(defn alter-cell [x y grid]\n  (assoc-in grid [x y] {:north 1, :east 1, :south 1, :west 1}))\n\n(defn maze-row [x y maze]\n  (loop [count 0 grid maze]\n    (if (= y count)\n      grid\n      (recur (inc count) (alter-cell x y grid)))))\n\n(defn maze-grid [rows columns maze]\n  (loop [count 0 grid maze]  ; loop over rows of empty grid\n    (println grid)\n    (if (= rows count)\n      grid  ;return grid\n      (recur (inc count) (maze-row count columns grid))))) ;return value of maze-row is now grid\n\n(generate-maze [rows cols]\n               ;uses empty grid and row col numbers\n               (maze-grid rows cols (make-a-grid rows cols)))\n\n;generate maze function\n(generate-maze 4 4)&quot;, :offset 676, :ns &quot;user&quot;} {:command &quot;(defn generate-maze [rows cols]\n  ;uses empty grid and row col numbers\n  (maze-grid rows cols (make-a-grid rows cols)))\n\n;generate maze function\n(generate-maze 4 4)\n&quot;, :offset 165, :ns &quot;user&quot;} {:command &quot;(&gt; 4 1)&quot;, :offset 6, :ns &quot;user&quot;} {:command &quot;(&gt;= 4 (count maze))&quot;, :offset 6, :ns &quot;user&quot;} {:command &quot;(&gt;= 3 (count maze))&quot;, :offset 5, :ns &quot;user&quot;} {:command &quot;(&gt;= 5 (count maze))&quot;, :offset 5, :ns &quot;user&quot;} {:command &quot;(count(get-in maze [0]))&quot;, :offset 6, :ns &quot;user&quot;} {:command &quot;\n(generate-maze 10 4)&quot;, :offset 0, :ns &quot;user&quot;} {:command &quot;(count(get-in\n        (generate-maze 10 4) [0]))&quot;, :offset 42, :ns &quot;user&quot;} {:command &quot;(do\n  (assoc-in maze [0 0 :east] 77)\n  (assoc-in maze [0 (+ 0 1) :west] 77))&quot;, :offset 76, :ns &quot;user&quot;} {:command &quot;(assoc-in  (assoc-in maze [0 (+ 0 1) :west] 77) [0 0 :east] 77)\n &quot;, :offset 63, :ns &quot;user&quot;} {:command &quot;(defn alter-cell [x y grid]\n  (cond\n    ; top row &amp; last cell do nothing\n    (and (= x (count grid)) (= y (count(get-in grid [0])))) grid\n    ;if top row only carve east\n    (= x 0) (assoc-in (assoc-in maze [x (+ y 1) :west] 1) [x y :east] 1)\n    ;;if eastern cell carve north\n    ;(= y (count(get-in grid [0]))) (assoc-in grid [x y :east] 1)\n\n\n    ))\n\n(defn maze-row [x y maze]\n  (loop [count 0 grid maze]\n    (if (= y count)\n      grid\n      (recur (inc count) (alter-cell x count grid)))))\n\n(defn maze-grid [rows columns maze]\n  (loop [count 0 grid maze]  ; loop over rows of empty grid\n    (println grid)\n    (if (= rows count)\n      grid  ;return grid\n      (recur (inc count) (maze-row count columns grid))))) ;return value of maze-row is now grid\n\n(defn generate-maze [rows cols]\n  ;uses empty grid and row col numbers\n  (maze-grid rows cols (make-a-grid rows cols)))\n\n;generate maze function\n(generate-maze 4 4)&quot;, :offset 919, :ns &quot;user&quot;} {:command &quot;(generate-maze 4 4)&quot;, :offset 19, :ns &quot;user&quot;} {:command &quot;(defn alter-cell [x y grid]\n  (cond\n    ; top row &amp; last cell do nothing\n    (and (= x (count grid)) (= y (count(get-in grid [0])))) grid\n    ;if top row only carve east\n    (= x 0) (assoc-in (assoc-in maze [x (+ y 1) :west] 1) [x y :east] 1)\n    ;;if eastern cell carve north\n    ;(= y (count(get-in grid [0]))) (assoc-in grid [x y :east] 1)\n\n\n    ))\n\n(defn maze-row [x y maze]\n  (loop [count 0 grid maze]\n    (if (= y count)\n      grid\n      (recur (inc count) (alter-cell x count grid)))))\n\n(defn maze-grid [rows columns maze]\n  (loop [count 0 grid maze]  ; loop over rows of empty grid\n    (if (= rows count)\n      grid  ;return grid\n      (recur (inc count) (maze-row count columns grid))))) ;return value of maze-row is now grid\n\n(defn generate-maze [rows cols]\n  ;uses empty grid and row col numbers\n  (maze-grid rows cols (make-a-grid rows cols)))\n\n;generate maze function\n(generate-maze 4 4)\n&quot;, :offset 901, :ns &quot;user&quot;} {:command &quot;(defn alter-cell [x y grid]\n  (assoc-in grid [x y] {:north 1, :east 1, :south 1, :west 1}))\n\n(defn maze-row [x y maze]\n  (loop [count 0 grid maze]\n    (if (= y count)\n      grid\n      (recur (inc count) (alter-cell x count grid)))))\n\n(defn maze-grid [rows columns maze]\n  (loop [count 0 grid maze]  ; loop over rows of empty grid\n    (println grid)\n    (if (= rows count)\n      grid  ;return grid\n      (recur (inc count) (maze-row count columns grid))))) ;return value of maze-row is now grid\n\n(defn generate-maze [rows cols]\n  ;uses empty grid and row col numbers\n  (maze-grid rows cols (make-a-grid rows cols)))\n\n;generate maze function\n(generate-maze 4 4)&quot;, :offset 659, :ns &quot;user&quot;} {:command &quot;\n(defn alter-cell [x y grid]\n  (cond\n    ; top row &amp; last cell do nothing\n    (and (= x (count grid)) (= y (count(get-in grid [0])))) grid\n    ;if top row only carve east\n    (= x 0) (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n    ;;if eastern cell carve north\n    ;(= y (count(get-in grid [0]))) (assoc-in grid [x y :east] 1)\n\n\n    ))\n\n(defn maze-row [x y maze]\n  (loop [count 0 grid maze]\n    (if (= y count)\n      grid\n      (recur (inc count) (alter-cell x count grid)))))\n\n(defn maze-grid [rows columns maze]\n  (loop [count 0 grid maze]  ; loop over rows of empty grid\n    (if (= rows count)\n      grid  ;return grid\n      (recur (inc count) (maze-row count columns grid))))) ;return value of maze-row is now grid\n\n(defn generate-maze [rows cols]\n  ;uses empty grid and row col numbers\n  (maze-grid rows cols (make-a-grid rows cols)))\n\n;generate maze function\n(generate-maze 4 4)&quot;, :offset 901, :ns &quot;user&quot;} {:command &quot;(defn alter-cell [x y grid]\n  (cond\n    ; top row &amp; last cell do nothing\n    (and (= x (count grid)) (= y (count(get-in grid [0])))) grid\n    ;if top row only carve east\n    (= x 0) (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n    ;if eastern cell carve north\n    (= y (count(get-in grid [0]))) (assoc-in (assoc-in grid [(+ x 1) y :south] 1) [x y :north] 1)\n    ; not top row carve north or east\n    :else\n    (if (= 0 (rand-int 2))\n      (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n      (assoc-in (assoc-in grid [(+ x 1) y :south] 1) [x y :north] 1)))&quot;, :offset 586, :ns &quot;user&quot;} {:command &quot;(make-a-grid 2 2)&quot;, :offset 16, :ns &quot;user&quot;} {:command &quot;(defn make-a-row [columns]\n  (loop [count 0 row []]\n    (if (= columns count)\n      row\n      (recur (inc count) (conj row {:north 0 :east 0 :south 0 :west 0})))))\n\n(defn make-a-grid [rows columns]\n  (loop [count 0 grid []]\n    (if (= rows count)\n      grid\n      (recur (inc count) (conj grid (make-a-row columns))))))\n\n(defn alter-cell [x y grid]\n  (cond\n    ; top row &amp; last cell do nothing\n    (and (= x (count grid)) (= y (count(get-in grid [0])))) grid\n    ;if top row only carve east\n    (= x 0) (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n    ;if eastern cell carve north\n    (= y (count(get-in grid [0]))) (assoc-in (assoc-in grid [(+ x 1) y :south] 1) [x y :north] 1)\n    ; not top row carve north or east\n    :else\n    (if (= 0 (rand-int 2))\n      (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n      (assoc-in (assoc-in grid [(+ x 1) y :south] 1) [x y :north] 1)))\n\n  (defn maze-row [x y maze]\n    (loop [count 0 grid maze]\n      (if (= y count)\n        grid\n        (recur (inc count) (alter-cell x count grid)))))\n\n  (defn maze-grid [rows columns maze]\n    (loop [count 0 grid maze]  ; loop over rows of empty grid\n      (if (= rows count)\n        grid  ;return grid\n        (recur (inc count) (maze-row count columns grid))))) ;return value of maze-row is now grid\n\n  (defn generate-maze [rows cols]\n    ;uses empty grid and row col numbers\n    (maze-grid rows cols (make-a-grid rows cols)))\n\n  ;generate maze function\n  (generate-maze 4 4)&quot;, :offset 1486, :ns &quot;user&quot;} {:command &quot;(defn make-a-row [columns]\n  (loop [count 0 row []]\n    (if (= columns count)\n      row\n      (recur (inc count) (conj row {:north 0 :east 0 :south 0 :west 0})))))\n\n(defn make-a-grid [rows columns]\n  (loop [count 0 grid []]\n    (if (= rows count)\n      grid\n      (recur (inc count) (conj grid (make-a-row columns))))))\n\n(defn alter-cell [x y grid]\n  (cond\n    ; top row &amp; last cell do nothing\n    (and (= x (count grid)) (= y (count(get-in grid [0])))) grid\n    ;if top row only carve east\n    (= x 0) (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n    ;if eastern cell carve north\n    (= y (count(get-in grid [0]))) (assoc-in (assoc-in grid [(+ x 1) y :south] 1) [x y :north] 1)\n    ; not top row carve north or east\n    :else\n    (if (= 0 (rand-int 2))\n      (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n      (assoc-in (assoc-in grid [(+ x 1) y :south] 1) [x y :north] 1))))\n\n(defn maze-row [x y maze]\n  (loop [count 0 grid maze]\n    (if (= y count)\n      grid\n      (recur (inc count) (alter-cell x count grid)))))\n\n(defn maze-grid [rows columns maze]\n  (loop [count 0 grid maze]  ; loop over rows of empty grid\n    (if (= rows count)\n      grid  ;return grid\n      (recur (inc count) (maze-row count columns grid))))) ;return value of maze-row is now grid\n\n(defn generate-maze [rows cols]\n  ;uses empty grid and row col numbers\n  (maze-grid rows cols (make-a-grid rows cols)))\n\n;generate maze function\n(generate-maze 4 4)&quot;, :offset 1457, :ns &quot;user&quot;} {:command &quot;(defn alter-cell [x y grid]\n  (cond\n    ; top row &amp; last cell do nothing\n    (and (= x 0) (= y (count(get-in grid [0])))) grid\n    ;if top row only carve east\n    (= x 0) (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n    ;if eastern cell carve north\n    (= y (count(get-in grid [0]))) (assoc-in (assoc-in grid [(+ x 1) y :south] 1) [x y :north] 1)\n    ; not top row carve north or east\n    :else\n    (if (= 0 (rand-int 2))\n      (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n      (assoc-in (assoc-in grid [(+ x 1) y :south] 1) [x y :north] 1))))\n\n(defn maze-row [x y maze]\n  (loop [count 0 grid maze]\n    (if (= y count)\n      grid\n      (recur (inc count) (alter-cell x count grid)))))\n\n(defn maze-grid [rows columns maze]\n  (loop [count 0 grid maze]  ; loop over rows of empty grid\n    (if (= rows count)\n      grid  ;return grid\n      (recur (inc count) (maze-row count columns grid))))) ;return value of maze-row is now grid\n\n(defn generate-maze [rows cols]\n  ;uses empty grid and row col numbers\n  (maze-grid rows cols (make-a-grid rows cols)))\n\n;generate maze function\n(generate-maze 4 4)&quot;, :offset 1125, :ns &quot;user&quot;} {:command &quot;(defn alter-cell [x y grid]\n  (cond\n    ; top row &amp; last cell do nothing\n    (and (= x 0) (= y (count(get-in grid [0])))) grid\n    ;if top row only carve east\n    (= x 0) (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n    ;if eastern cell carve north\n    (= y (count(get-in grid [0]))) (assoc-in (assoc-in grid [(- x 1) y :south] 1) [x y :north] 1)\n    ; not top row carve north or east\n    :else\n    (if (= 0 (rand-int 2))\n      (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n      (assoc-in (assoc-in grid [(- x 1) y :south] 1) [x y :north] 1))))\n\n(defn maze-row [x y maze]\n  (loop [count 0 grid maze]\n    (if (= y count)\n      grid\n      (recur (inc count) (alter-cell x count grid)))))\n\n(defn maze-grid [rows columns maze]\n  (loop [count 0 grid maze]  ; loop over rows of empty grid\n    (if (= rows count)\n      grid  ;return grid\n      (recur (inc count) (maze-row count columns grid))))) ;return value of maze-row is now grid\n\n(defn generate-maze [rows cols]\n  ;uses empty grid and row col numbers\n  (maze-grid rows cols (make-a-grid rows cols)))\n\n;generate maze function\n(generate-maze 4 4)\n&quot;, :offset 1126, :ns &quot;user&quot;} {:command &quot;(defn alter-cell [x y grid]\n  (cond\n    ; top row &amp; last cell do nothing\n    (and (= x 0) (= y (- (count(get-in grid [0])) 1))) grid\n    ;if top row only carve east\n    (= x 0) (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n    ;if eastern cell carve north\n    (= y (count(get-in grid [0]))) (assoc-in (assoc-in grid [(- x 1) y :south] 1) [x y :north] 1)\n    ; not top row carve north or east\n    :else\n    (if (= 0 (rand-int 2))\n      (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n      (assoc-in (assoc-in grid [(- x 1) y :south] 1) [x y :north] 1))))\n\n(defn maze-row [x y maze]\n  (loop [count 0 grid maze]\n    (if (= y count)\n      grid\n      (recur (inc count) (alter-cell x count grid)))))\n\n(defn maze-grid [rows columns maze]\n  (loop [count 0 grid maze]  ; loop over rows of empty grid\n    (if (= rows count)\n      grid  ;return grid\n      (recur (inc count) (maze-row count columns grid))))) ;return value of maze-row is now grid\n\n(defn generate-maze [rows cols]\n  ;uses empty grid and row col numbers\n  (maze-grid rows cols (make-a-grid rows cols)))\n\n;generate maze function\n(generate-maze 4 4)&quot;, :offset 1131, :ns &quot;user&quot;} {:command &quot;(defn alter-cell [x y grid]\n  (cond\n    ; top row &amp; last cell do nothing\n    (and (= x 0) (= y (- (count(get-in grid [0])) 1))) grid\n    ;if top row only carve east\n    (= x 0) (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n    ;if eastern cell carve north\n    (= y (- (count(get-in grid [0])) 1)) (assoc-in (assoc-in grid [(- x 1) y :south] 1) [x y :north] 1)\n    ; not top row carve north or east\n    :else\n    (if (= 0 (rand-int 2))\n      (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n      (assoc-in (assoc-in grid [(- x 1) y :south] 1) [x y :north] 1))))\n\n(defn maze-row [x y maze]\n  (loop [count 0 grid maze]\n    (if (= y count)\n      grid\n      (recur (inc count) (alter-cell x count grid)))))\n\n(defn maze-grid [rows columns maze]\n  (loop [count 0 grid maze]  ; loop over rows of empty grid\n    (if (= rows count)\n      grid  ;return grid\n      (recur (inc count) (maze-row count columns grid))))) ;return value of maze-row is now grid\n\n(defn generate-maze [rows cols]\n  ;uses empty grid and row col numbers\n  (maze-grid rows cols (make-a-grid rows cols)))\n\n;generate maze function\n(generate-maze 4 4)&quot;, :offset 1137, :ns &quot;user&quot;} {:command &quot;(generate-maze 5 5)&quot;, :offset 19, :ns &quot;user&quot;} {:command &quot;(def maze (generate-maze 3 3))&quot;, :offset 28, :ns &quot;user&quot;} {:command &quot;(print \&quot;+\&quot;)\n(for [x (range 0 (count (first maze))) ]\n  (print \&quot;---+\&quot;))\n(print \&quot;\\n\&quot;)&quot;, :offset 83, :ns &quot;+&quot;} {:command &quot;(print \&quot;*\&quot; (* \&quot;---+\&quot; 5))&quot;, :offset 24, :ns &quot;+&quot;} {:command &quot;(print \&quot;*\&quot; (repeat 2 \&quot;---+\&quot;))&quot;, :offset 29, :ns &quot;+&quot;} {:command &quot;(apply str (repeat 3 \&quot;str\&quot;))&quot;, :offset 10, :ns &quot;user&quot;} {:command &quot;(apply str (repeat 3 \&quot;---+\&quot;))&quot;, :offset 29, :ns &quot;user&quot;} {:command &quot;(apply str \&quot;+\&quot; (repeat 3 \&quot;---+\&quot;))&quot;, :offset 13, :ns &quot;user&quot;} {:command &quot;(apply str \&quot;+\&quot; (repeat (count maze) \&quot;---+\&quot;) \&quot;\\n\&quot;)&quot;, :offset 34, :ns &quot;user&quot;} {:command &quot;(apply str \&quot;+\&quot; (repeat (count maze) \&quot;---+\&quot;))&quot;, :offset 44, :ns &quot;user&quot;} {:command &quot;(println(apply str \&quot;+\&quot; (repeat (count maze) \&quot;---+\&quot;)))&quot;, :offset 8, :ns &quot;user&quot;} {:command &quot;(println (apply str \&quot;+\&quot; (repeat (count maze) \&quot;---+\&quot;)))&quot;, :offset 54, :ns &quot;user&quot;} {:command &quot;(for [x maze]\n  (println x))&quot;, :offset 26, :ns &quot;user&quot;} {:command &quot;(for [x maze [0]]\n  (println x))&quot;, :offset 15, :ns &quot;user&quot;} {:command &quot;(for [x maze[0]]\n  (println x))&quot;, :offset 12, :ns &quot;user&quot;} {:command &quot;(for [x (get-in maze[0])]\n  (println x))&quot;, :offset 16, :ns &quot;user&quot;} {:command &quot;(for [x maze]\n  (for [y x]\n    (println y)))&quot;, :offset 41, :ns &quot;user&quot;} {:command &quot;(&gt; 0 (count maze))&quot;, :offset 16, :ns &quot;user&quot;} {:command &quot;(&lt; 0 (count maze))&quot;, :offset 18, :ns &quot;user&quot;} {:command &quot;(&lt; 3 (count maze))&quot;, :offset 5, :ns &quot;user&quot;} {:command &quot;(&lt; 2 (count maze))&quot;, :offset 4, :ns &quot;user&quot;} {:command &quot;(defn to-s [grid]\n  (println (apply str \&quot;+\&quot; (repeat (count (get-in grid [0])) \&quot;---+\&quot;)))\n  (loop [x 0]\n    (when (&lt; x (count grid))\n      (for [col (get-in grid [x])]\n        (if (contains? col :east) (print \&quot;|   \&quot;)))\n      (println)\n      (print \&quot;+\&quot;)\n      (for [col row]\n        (if (contains? col :south) (print \&quot;---+\&quot;) (print \&quot;   +\&quot;)))\n      (println)\n      (recur (+ x 1)))))\n\n(to-s maze)\n&quot;, :offset 393, :ns &quot;user&quot;} {:command &quot;(defn to-s [grid]\n  (println (apply str \&quot;+\&quot; (repeat (count (get-in grid [0])) \&quot;---+\&quot;)))\n  (loop [x 0]\n    (when (&lt; x (count grid))\n      (for [col (get-in grid [x])]\n        (if (contains? col :east) (print \&quot;|   \&quot;)))\n      (println)\n      (print \&quot;+\&quot;)\n      (for [col (get-in grid [x])]\n        (if (contains? col :south) (print \&quot;---+\&quot;) (print \&quot;   +\&quot;)))\n      (println)\n      (recur (+ x 1)))))\n\n(to-s maze)&quot;, :offset 406, :ns &quot;user&quot;} {:command &quot;maze&quot;, :offset 4, :ns &quot;user&quot;} {:command &quot;(defn to-s [grid]\n  (println (apply str \&quot;+\&quot; (repeat (count (get-in grid [0])) \&quot;---+\&quot;)))\n  (loop [x 0]\n    (when (&lt; x (count grid))\n      (println (apply str (for [col (get-in grid [x])]\n                            (if (contains? col :east) (print \&quot;|   \&quot;)(print \&quot;    \&quot;)))))\n      (print \&quot;+\&quot;)\n      (println (apply str (for [col (get-in grid [x])]\n                            (if (contains? col :south) (print \&quot;---+\&quot;) (print \&quot;   +\&quot;)))))\n      (recur (+ x 1)))))\n\n(to-s maze)&quot;, :offset 472, :ns &quot;user&quot;} {:command &quot;({:north 0, :east 1, :south 1, :west 0} :south)&quot;, :offset 46, :ns &quot;user&quot;} {:command &quot;(defn to-s [grid]\n  (println (apply str \&quot;+\&quot; (repeat (count (get-in grid [0])) \&quot;---+\&quot;)))\n  (loop [x 0]\n    (when (&lt; x (count grid))\n      (println (apply str \&quot;|\&quot; (for [col (get-in grid [x])]\n                                (if (= (col :east) 0) (print \&quot;   |\&quot;)(print \&quot;    \&quot;)))))\n      (println (apply str \&quot;+\&quot; (for [col (get-in grid [x])]\n                                (if (= (col :south) 0) (print \&quot;---+\&quot;) (print \&quot;   +\&quot;)))))\n      (recur (+ x 1)))))\n\n(to-s maze)\n&quot;, :offset 463, :ns &quot;user&quot;} {:command &quot;(defn to-s [grid]\n  (println (apply str \&quot;+\&quot; (repeat (count (get-in grid [0])) \&quot;---+\&quot;)))\n  (loop [x 0]\n    (when (&lt; x (count grid))\n      (println (apply str \&quot;|\&quot; (for [col (get-in grid [x])]\n                                (if (= (col :east) 0) \&quot;   |\&quot; \&quot;    \&quot;))))\n      (println (apply str \&quot;+\&quot; (for [col (get-in grid [x])]\n                                (if (= (col :south) 0) \&quot;---+\&quot;\&quot;   +\&quot;))))\n      (recur (+ x 1)))))\n\n(to-s maze)&quot;, :offset 430, :ns &quot;user&quot;} {:command &quot;(to-s (generate-maze 6 4))&quot;, :offset 26, :ns &quot;user&quot;} {:command &quot;\n(to-s (generate-maze 40 40))&quot;, :offset 23, :ns &quot;user&quot;} {:command &quot;(ns maze-task-2.core\n  (:require [monger.core :as mg]\n            [monger.collection :as mc]\n            [clojure.data.json :as json]\n            [compojure.core :refer :all]\n            [compojure.route :as route]\n            [compojure.handler :refer [site]]\n            [ring.middleware.defaults :refer :all]\n            [ring.middleware.params :refer [wrap-params]]\n            [clojure.java.jdbc :as sql]\n            [stencil.core :refer [render-string]]\n            [ring.adapter.jetty :as jetty])\n  (:import [com.mongodb MongoOptions ServerAddress]\n           [org.bson.types ObjectId]\n           [com.mongodb DB WriteConcern]))\n&quot;, :offset 636, :ns &quot;user&quot;} {:command &quot;(defn generate-maze-json [rows cols]\n  (json/write-str (generate-maze 10 10)))&quot;, :offset 78, :ns &quot;maze-task-2.core&quot;} {:command &quot;(defn make-a-row [columns]\n  (loop [count 0 row []]\n    (if (= columns count)\n      row\n      (recur (inc count) (conj row {:north 0 :east 0 :south 0 :west 0})))))\n\n(defn make-a-grid [rows columns]\n  (loop [count 0 grid []]\n    (if (= rows count)\n      grid\n      (recur (inc count) (conj grid (make-a-row columns))))))\n\n(defn alter-cell [x y grid]\n  (cond\n    ; top row &amp; last cell do nothing\n    (and (= x 0) (= y (- (count(get-in grid [0])) 1))) grid\n    ;if top row only carve east\n    (= x 0) (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n    ;if eastern cell carve north\n    (= y (- (count(get-in grid [0])) 1)) (assoc-in (assoc-in grid [(- x 1) y :south] 1) [x y :north] 1)\n    ; not top row carve north or east\n    :else\n    (if (= 0 (rand-int 2))\n      (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n      (assoc-in (assoc-in grid [(- x 1) y :south] 1) [x y :north] 1))))\n\n(defn maze-row [x y maze]\n  (loop [count 0 grid maze]\n    (if (= y count)\n      grid\n      (recur (inc count) (alter-cell x count grid)))))\n\n(defn maze-grid [rows columns maze]\n  (loop [count 0 grid maze]  ; loop over rows of empty grid\n    (if (= rows count)\n      grid  ;return grid\n      (recur (inc count) (maze-row count columns grid))))) ;return value of maze-row is now grid\n\n(defn generate-maze [rows cols]\n  ;uses empty grid and row col numbers\n  (maze-grid rows cols (make-a-grid rows cols)))\n\n(defn to-s [grid]\n  (println (apply str \&quot;+\&quot; (repeat (count (get-in grid [0])) \&quot;---+\&quot;)))\n  (loop [x 0]\n    (when (&lt; x (count grid))\n      (println (apply str \&quot;|\&quot; (for [col (get-in grid [x])]\n                                (if (= (col :east) 0) \&quot;   |\&quot; \&quot;    \&quot;))))\n      (println (apply str \&quot;+\&quot; (for [col (get-in grid [x])]\n                                (if (= (col :south) 0) \&quot;---+\&quot;\&quot;   +\&quot;))))\n      (recur (+ x 1)))))\n\n(defn generate-maze-json [rows cols]\n  (json/write-str (generate-maze 10 10)))\n\n(defn (to-s (generate-maze 10 10)))&quot;, :offset 1949, :ns &quot;maze-task-2.core&quot;} {:command &quot;\n(defn generate-maze-json [rows cols]\n  (json/write-str (generate-maze 10 10)))&quot;, :offset 79, :ns &quot;maze-task-2.core&quot;} {:command &quot;\n(defn generate-maze-json [rows cols]\n  (print(json/write-str (generate-maze 10 10))))&quot;, :offset 46, :ns &quot;maze-task-2.core&quot;} {:command &quot;(defn generate-maze-json [rows cols]\n  (json/write-str (generate-maze 10 10)))\n(generate-maze-json 5 5)&quot;, :offset 103, :ns &quot;maze-task-2.core&quot;} {:command &quot;\n(to-s (generate-maze 10 10))&quot;, :offset 29, :ns &quot;maze-task-2.core&quot;} {:command &quot;\n\n(to-s (generate-maze 10 10))&quot;, :offset 2, :ns &quot;maze-task-2.core&quot;} {:command &quot;(defn to-s [grid]\n  (println (apply str \&quot;+\&quot; (repeat (count (get-in grid [0])) \&quot;----+\&quot;)))\n  (loop [x 0]\n    (when (&lt; x (count grid))\n      (println (apply str \&quot;|\&quot; (for [col (get-in grid [x])]\n                                (if (= (col :east) 0) \&quot;    |\&quot; \&quot;     \&quot;))))\n      (println (apply str \&quot;+\&quot; (for [col (get-in grid [x])]\n                                (if (= (col :south) 0) \&quot;----+\&quot;\&quot;   +\&quot;))))\n      (recur (+ x 1)))))&quot;, :offset 421, :ns &quot;maze-task-2.core&quot;} {:command &quot;(defn to-s [grid]\n  (println (apply str \&quot;+\&quot; (repeat (count (get-in grid [0])) \&quot;----+\&quot;)))\n  (loop [x 0]\n    (when (&lt; x (count grid))\n      (println (apply str \&quot;|\&quot; (for [col (get-in grid [x])]\n                                (if (= (col :east) 0) \&quot;    |\&quot; \&quot;     \&quot;))))\n      (println (apply str \&quot;+\&quot; (for [col (get-in grid [x])]\n                                (if (= (col :south) 0) \&quot;----+\&quot;\&quot;    +\&quot;))))\n      (recur (+ x 1)))))&quot;, :offset 422, :ns &quot;maze-task-2.core&quot;} {:command &quot;\n\n\n(to-s (generate-maze 10 10))&quot;, :offset 3, :ns &quot;maze-task-2.core&quot;} {:command &quot;(defn make-a-row [columns]\n  (loop [count 0 row []]\n    (if (= columns count)\n      row\n      (recur (inc count) (conj row {:north 0 :east 0 :south 0 :west 0})))))\n\n(defn make-a-grid [rows columns]\n  (loop [count 0 grid []]\n    (if (= rows count)\n      grid\n      (recur (inc count) (conj grid (make-a-row columns))))))\n\n(defn binary-alter-cell [x y grid]\n  (cond\n    ; top row &amp; last cell do nothing\n    (and (= x 0) (= y (- (count(get-in grid [0])) 1))) grid\n    ;if top row only carve east\n    (= x 0) (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n    ;if eastern cell carve north\n    (= y (- (count(get-in grid [0])) 1)) (assoc-in (assoc-in grid [(- x 1) y :south] 1) [x y :north] 1)\n    ; not top row carve north or east\n    :else\n    (if (= 0 (rand-int 2))\n      (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n      (assoc-in (assoc-in grid [(- x 1) y :south] 1) [x y :north] 1))))\n\n(defn binary-maze-row [x y maze]\n  (loop [count 0 grid maze]\n    (if (= y count)\n      grid\n      (recur (inc count) (binary-alter-cell x count grid)))))\n\n(defn binary-maze-grid [rows columns maze]\n  (loop [count 0 grid maze]  ; loop over rows of empty grid\n    (if (= rows count)\n      grid  ;return grid\n      (recur (inc count) (binary-maze-row count columns grid))))) ;return value of maze-row is now grid\n\n(defn binary-generate-maze [rows cols]\n  ;uses empty grid and row col numbers\n  (binary-maze-grid rows cols (make-a-grid rows cols)))\n\n(defn to-s [grid]\n  (println (apply str \&quot;+\&quot; (repeat (count (get-in grid [0])) \&quot;----+\&quot;)))\n  (loop [x 0]\n    (when (&lt; x (count grid))\n      (println (apply str \&quot;|\&quot; (for [col (get-in grid [x])]\n                                (if (= (col :east) 0) \&quot;    |\&quot; \&quot;     \&quot;))))\n      (println (apply str \&quot;+\&quot; (for [col (get-in grid [x])]\n                                (if (= (col :south) 0) \&quot;----+\&quot;\&quot;    +\&quot;))))\n      (recur (+ x 1)))))\n\n(defn binary-generate-maze-json [rows cols]\n  (json/write-str (binary-generate-maze 10 10)))\n(binary-generate-maze-json 5 5)\n\n(to-s (binary-generate-maze 10 10))&quot;, :offset 2049, :ns &quot;maze-task-2.core&quot;} {:command &quot;(defn make-a-row [columns]\n  (loop [count 0 row []]\n    (if (= columns count)\n      row\n      (recur (inc count) (conj row {:north 0 :east 0 :south 0 :west 0})))))\n\n(defn make-a-grid [rows columns]\n  (loop [count 0 grid []]\n    (if (= rows count)\n      grid\n      (recur (inc count) (conj grid (make-a-row columns))))))\n\n(defn binary-alter-cell [x y grid]\n  (cond\n    ; top row &amp; last cell do nothing\n    (and (= x 0) (= y (- (count(get-in grid [0])) 1))) grid\n    ;if top row only carve east\n    (= x 0) (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n    ;if eastern cell carve north\n    (= y (- (count(get-in grid [0])) 1)) (assoc-in (assoc-in grid [(- x 1) y :south] 1) [x y :north] 1)\n    ; not top row carve north or east\n    :else\n    (if (= 0 (rand-int 2))\n      (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n      (assoc-in (assoc-in grid [(- x 1) y :south] 1) [x y :north] 1))))\n\n(defn binary-maze-row [x y maze]\n  (loop [count 0 grid maze]\n    (if (= y count)\n      grid\n      (recur (inc count) (binary-alter-cell x count grid)))))\n\n(defn binary-maze-grid [rows columns maze]\n  (loop [count 0 grid maze]  ; loop over rows of empty grid\n    (if (= rows count)\n      grid  ;return grid\n      (recur (inc count) (binary-maze-row count columns grid))))) ;return value of maze-row is now grid\n\n(defn binary-generate-maze [rows cols]\n  ;uses empty grid and row col numbers\n  (binary-maze-grid rows cols (make-a-grid rows cols)))&quot;, :offset 1462, :ns &quot;user&quot;} {:command &quot;(defn to-s [grid]\n  (apply str \&quot;+\&quot; (repeat (count (get-in grid [0])) \&quot;----+\&quot;) \&quot;\\n\&quot;)\n  (loop [x 0]\n    (when (&lt; x (count grid))\n      (apply str \&quot;|\&quot; (for [col (get-in grid [x])]\n                       (if (= (col :east) 0) \&quot;    |\&quot; \&quot;     \&quot;)) \&quot;\\n\&quot;)\n      (apply str \&quot;+\&quot; (for [col (get-in grid [x])]\n                       (if (= (col :south) 0) \&quot;----+\&quot;\&quot;    +\&quot;)) \&quot;\\n\&quot;)\n      (recur (+ x 1)))))\n\n(to-s (binary-generate-maze 10 10))&quot;, :offset 426, :ns &quot;user&quot;} {:command &quot;(defn to-s [grid]\n  (loop [x 0 output (apply str \&quot;+\&quot; (repeat (count (get-in grid [0])) \&quot;----+\&quot;) \&quot;\\n\&quot;)]\n    (when (&lt; x (count grid))\n      (str output (apply str \&quot;|\&quot; (for [col (get-in grid [x])]\n                       (if (= (col :east) 0) \&quot;    |\&quot; \&quot;     \&quot;)) \&quot;\\n\&quot;))\n      (str output (apply str \&quot;+\&quot; (for [col (get-in grid [x])]\n                       (if (= (col :south) 0) \&quot;----+\&quot;\&quot;    +\&quot;)) \&quot;\\n\&quot;))\n      (recur (+ x 1)))\n    output))\n\n(to-s (binary-generate-maze 10 10))&quot;, :offset 468, :ns &quot;user&quot;} {:command &quot;(defn to-s [grid]\n  (loop [x 0 output (apply str \&quot;+\&quot; (repeat (count (get-in grid [0])) \&quot;----+\&quot;) \&quot;\\n\&quot;)]\n    (when (&lt; x (count grid))\n      (str output (apply str \&quot;|\&quot; (for [col (get-in grid [x])]\n                       (if (= (col :east) 0) \&quot;    |\&quot; \&quot;     \&quot;)) \&quot;\\n\&quot;))\n      (str output (apply str \&quot;+\&quot; (for [col (get-in grid [x])]\n                       (if (= (col :south) 0) \&quot;----+\&quot;\&quot;    +\&quot;)) \&quot;\\n\&quot;))\n      (recur (+ x 1) output))\n    output))\n\n(to-s (binary-generate-maze 10 10))&quot;, :offset 438, :ns &quot;user&quot;} {:command &quot;(defn to-s [grid]\n  (loop [x 0 output (apply str \&quot;+\&quot; (repeat (count (get-in grid [0])) \&quot;----+\&quot;) \&quot;\\n\&quot;)]\n    (if (&gt;= x (count grid))\n      output\n      (recur (+ x 1) (str output (apply str \&quot;|\&quot; (for [col (get-in grid [x])]\n                                                  (if (= (col :east) 0) \&quot;    |\&quot; \&quot;     \&quot;)) \&quot;\\n\&quot;)\n                          (apply str \&quot;+\&quot; (for [col (get-in grid [x])]\n                                           (if (= (col :south) 0) \&quot;----+\&quot;\&quot;    +\&quot;)) \&quot;\\n\&quot;))))))\n\n(to-s (binary-generate-maze 10 10))&quot;, :offset 517, :ns &quot;user&quot;} {:command &quot;(defn to-s [grid]\n  (loop [x 0 output (apply str \&quot;+\&quot; (repeat (count (get-in grid [0])) \&quot;----+\&quot;) \&quot;\\n\&quot;)]\n    (if (&gt;= x (count grid))\n      output\n      (recur (+ x 1) (str output \&quot;|\&quot; (for [col (get-in grid [x])]\n                                                  (if (= (col :east) 0) \&quot;    |\&quot; \&quot;     \&quot;)) \&quot;\\n\&quot;\n                          \&quot;+\&quot; (for [col (get-in grid [x])]\n                                           (if (= (col :south) 0) \&quot;----+\&quot;\&quot;    +\&quot;)) \&quot;\\n\&quot;)))))\n\n(to-s (binary-generate-maze 10 10))&quot;, :offset 493, :ns &quot;user&quot;} {:command &quot;(defn to-s [grid]\n  (loop [x 0 output (str \&quot;+\&quot; (repeat (count (get-in grid [0])) \&quot;----+\&quot;) \&quot;\\n\&quot;)]\n    (if (&gt;= x (count grid))\n      output\n      (recur (+ x 1) (str output \&quot;|\&quot; (for [col (get-in grid [x])]\n                                                  (if (= (col :east) 0) \&quot;    |\&quot; \&quot;     \&quot;)) \&quot;\\n\&quot;\n                          \&quot;+\&quot; (for [col (get-in grid [x])]\n                                           (if (= (col :south) 0) \&quot;----+\&quot;\&quot;    +\&quot;)) \&quot;\\n\&quot;)))))\n\n(to-s (binary-generate-maze 10 10))&quot;, :offset 39, :ns &quot;user&quot;} {:command &quot;(defn to-s [grid]\n  (loop [x 0 output (str \&quot;+\&quot; (repeat (count (get-in grid [0])) \&quot;----+\&quot;) \&quot;\\n\&quot;)]\n    (if (&gt;= x (count grid))\n      output\n      (recur (+ x 1) (apply str output \&quot;|\&quot; (for [col (get-in grid [x])]\n                                                  (if (= (col :east) 0) \&quot;    |\&quot; \&quot;     \&quot;)) \&quot;\\n\&quot;\n                          \&quot;+\&quot; (for [col (get-in grid [x])]\n                                           (if (= (col :south) 0) \&quot;----+\&quot;\&quot;    +\&quot;)) \&quot;\\n\&quot;)))))\n\n(to-s (binary-generate-maze 10 10))&quot;, :offset 493, :ns &quot;user&quot;} {:command &quot;(defn to-s [grid]\n  (loop [x 0 output (str \&quot;+\&quot; (repeat (count (get-in grid [0])) \&quot;----+\&quot;) \&quot;\\n\&quot;)]\n    (if (&gt;= x (count grid))\n      output\n      (recur (+ x 1) (apply str output \&quot;|\&quot; (apply str(for [col (get-in grid [x])]\n                                                  (if (= (col :east) 0) \&quot;    |\&quot; \&quot;     \&quot;))) \&quot;\\n\&quot;\n                          \&quot;+\&quot; (apply str(for [col (get-in grid [x])]\n                                           (if (= (col :south) 0) \&quot;----+\&quot;\&quot;    +\&quot;))) \&quot;\\n\&quot;)))))\n\n(to-s (binary-generate-maze 10 10))&quot;, :offset 356, :ns &quot;user&quot;} {:command &quot;(defn to-s [grid]\n  (loop [x 0 output (apply str \&quot;+\&quot; (repeat (count (get-in grid [0])) \&quot;----+\&quot;) \&quot;\\n\&quot;)]\n    (if (&gt;= x (count grid))\n      output\n      (recur (+ x 1) (apply str output \&quot;|\&quot; (apply str(for [col (get-in grid [x])]\n                                                  (if (= (col :east) 0) \&quot;    |\&quot; \&quot;     \&quot;))) \&quot;\\n\&quot;\n                          \&quot;+\&quot; (apply str(for [col (get-in grid [x])]\n                                           (if (= (col :south) 0) \&quot;----+\&quot;\&quot;    +\&quot;))) \&quot;\\n\&quot;)))))\n\n(to-s (binary-generate-maze 10 10))&quot;, :offset 39, :ns &quot;user&quot;} {:command &quot;(defn to-s [grid]\n  (loop [x 0 output (apply str \&quot;+\&quot; (for [col (get-in grid [0])] \&quot;----+\&quot;) \&quot;\\n\&quot;)]\n    (if (&gt;= x (count grid))\n      output\n      (recur (+ x 1) (apply str output \&quot;|\&quot; (apply str(for [col (get-in grid [x])]\n                                                  (if (= (col :east) 0) \&quot;    |\&quot; \&quot;     \&quot;))) \&quot;\\n\&quot;\n                          \&quot;+\&quot; (apply str (for [col (get-in grid [x])]\n                                           (if (= (col :south) 0) \&quot;----+\&quot;\&quot;    +\&quot;))) \&quot;\\n\&quot;)))))\n\n(to-s (binary-generate-maze 10 10))&quot;, :offset 517, :ns &quot;user&quot;} {:command &quot;(defn to-s [grid]\n  (loop [x 0 output (apply str \&quot;+\&quot; (apply str(for [col (get-in grid [0])] \&quot;----+\&quot;)) \&quot;\\n\&quot;)]\n    (if (&gt;= x (count grid))\n      output\n      (recur (+ x 1) (apply str output \&quot;|\&quot; (apply str(for [col (get-in grid [x])]\n                                                  (if (= (col :east) 0) \&quot;    |\&quot; \&quot;     \&quot;))) \&quot;\\n\&quot;\n                          \&quot;+\&quot; (apply str (for [col (get-in grid [x])]\n                                           (if (= (col :south) 0) \&quot;----+\&quot;\&quot;    +\&quot;))) \&quot;\\n\&quot;)))))\n\n(to-s (binary-generate-maze 10 10))&quot;, :offset 63, :ns &quot;user&quot;} {:command &quot;(defn newline-to-br [s]\n  [:pre (clojure.string/replace s #\&quot;\\r\\n|\\n|\\r\&quot; \&quot;&lt;br /&gt;\\n\&quot;)])\n(newline-to-br (to-s (binary-generate-maze 5 5)))&quot;, :offset 135, :ns &quot;user&quot;} {:command &quot;(defn make-a-row [columns]\n  (loop [count 0 row []]\n    (if (= columns count)\n      row\n      (recur (inc count) (conj row {:north 0 :east 0 :south 0 :west 0})))))\n\n(defn make-a-grid [rows columns]\n  (loop [count 0 grid []]\n    (if (= rows count)\n      grid\n      (recur (inc count) (conj grid (make-a-row columns))))))\n\n(defn binary-alter-cell [x y grid]\n  (cond\n    ; top row &amp; last cell do nothing\n    (and (= x 0) (= y (- (count(get-in grid [0])) 1))) grid\n    ;if top row only carve east\n    (= x 0) (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n    ;if eastern cell carve north\n    (= y (- (count(get-in grid [0])) 1)) (assoc-in (assoc-in grid [(- x 1) y :south] 1) [x y :north] 1)\n    ; not top row carve north or east\n    :else\n    (if (= 0 (rand-int 2))\n      (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n      (assoc-in (assoc-in grid [(- x 1) y :south] 1) [x y :north] 1))))\n\n(defn binary-maze-row [x y maze]\n  (loop [count 0 grid maze]\n    (if (= y count)\n      grid\n      (recur (inc count) (binary-alter-cell x count grid)))))\n\n(defn binary-maze-grid [rows columns maze]\n  (loop [count 0 grid maze]  ; loop over rows of empty grid\n    (if (= rows count)\n      grid  ;return grid\n      (recur (inc count) (binary-maze-row count columns grid))))) ;return value of maze-row is now grid\n\n(defn binary-generate-maze [rows cols]\n  ;uses empty grid and row col numbers\n  (binary-maze-grid rows cols (make-a-grid rows cols)))\n\n(defn to-s [grid]  ;Returns the maze as a string\n  (loop [x 0 output (apply str \&quot;+\&quot; (apply str(for [col (get-in grid [0])] \&quot;----+\&quot;)) \&quot;\\n\&quot;)]\n    (if (&gt;= x (count grid))\n      output\n      (recur (+ x 1) (apply str output \&quot;|\&quot; (apply str(for [col (get-in grid [x])]\n                                                       (if (= (col :east) 0) \&quot;    |\&quot; \&quot;     \&quot;))) \&quot;\\n\&quot;\n                            \&quot;+\&quot; (apply str (for [col (get-in grid [x])]\n                                             (if (= (col :south) 0) \&quot;----+\&quot;\&quot;    +\&quot;))) \&quot;\\n\&quot;)))))\n\n(defn pp-maze [grid]  ;Prints the maze to console\n  (println (apply str \&quot;+\&quot; (repeat (count (get-in grid [0])) \&quot;----+\&quot;)))\n  (loop [x 0]\n    (when (&lt; x (count grid))\n      (println (apply str \&quot;|\&quot; (for [col (get-in grid [x])]\n                                (if (= (col :east) 0) \&quot;    |\&quot; \&quot;     \&quot;))))\n      (println (apply str \&quot;+\&quot; (for [col (get-in grid [x])]\n                                (if (= (col :south) 0) \&quot;----+\&quot;\&quot;    +\&quot;))))\n      (recur (+ x 1)))))\n\n(defn newline-to-br [s]\n  [:pre (clojure.string/replace s #\&quot;\\r\\n|\\n|\\r\&quot; \&quot;&lt;br /&gt;\\n\&quot;)])\n(newline-to-br (to-s (binary-generate-maze 5 5)))&quot;, :offset 2588, :ns &quot;user&quot;} {:command &quot;(use 'hiccup.core)\n(defn newline-to-br [s]\n  (html [:pre (clojure.string/replace s #\&quot;\\r\\n|\\n|\\r\&quot; \&quot;&lt;br /&gt;\\n\&quot;)]))\n(newline-to-br (to-s (binary-generate-maze 5 5)))&quot;, :offset 161, :ns &quot;user&quot;} {:command &quot;(ns maze-task-2.core\n  (:require [monger.core :as mg]\n            [monger.collection :as mc]\n            [clojure.data.json :as json]\n            [compojure.core :refer :all]\n            [compojure.route :as route]\n            [compojure.handler :refer [site]]\n            [ring.middleware.defaults :refer :all]\n            [ring.middleware.params :refer [wrap-params]]\n            [clojure.java.jdbc :as sql]\n            [stencil.core :refer [render-string]]\n            [ring.adapter.jetty :as jetty])\n  (:use [hiccup.core])\n  (:import [com.mongodb MongoOptions ServerAddress]\n           [org.bson.types ObjectId]\n           [com.mongodb DB WriteConcern]))\n\n(defn make-a-row [columns]\n  (loop [count 0 row []]\n    (if (= columns count)\n      row\n      (recur (inc count) (conj row {:north 0 :east 0 :south 0 :west 0})))))\n\n(defn make-a-grid [rows columns]\n  (loop [count 0 grid []]\n    (if (= rows count)\n      grid\n      (recur (inc count) (conj grid (make-a-row columns))))))\n\n(defn binary-alter-cell [x y grid]\n  (cond\n    ; top row &amp; last cell do nothing\n    (and (= x 0) (= y (- (count(get-in grid [0])) 1))) grid\n    ;if top row only carve east\n    (= x 0) (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n    ;if eastern cell carve north\n    (= y (- (count(get-in grid [0])) 1)) (assoc-in (assoc-in grid [(- x 1) y :south] 1) [x y :north] 1)\n    ; not top row carve north or east\n    :else\n    (if (= 0 (rand-int 2))\n      (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n      (assoc-in (assoc-in grid [(- x 1) y :south] 1) [x y :north] 1))))\n\n(defn binary-maze-row [x y maze]\n  (loop [count 0 grid maze]\n    (if (= y count)\n      grid\n      (recur (inc count) (binary-alter-cell x count grid)))))\n\n(defn binary-maze-grid [rows columns maze]\n  (loop [count 0 grid maze]  ; loop over rows of empty grid\n    (if (= rows count)\n      grid  ;return grid\n      (recur (inc count) (binary-maze-row count columns grid))))) ;return value of maze-row is now grid\n\n(defn binary-generate-maze [rows cols]\n  ;uses empty grid and row col numbers\n  (binary-maze-grid rows cols (make-a-grid rows cols)))\n\n(defn to-s [grid]  ;Returns the maze as a string\n  (loop [x 0 output (apply str \&quot;+\&quot; (apply str(for [col (get-in grid [0])] \&quot;----+\&quot;)) \&quot;\\n\&quot;)]\n    (if (&gt;= x (count grid))\n      output\n      (recur (+ x 1) (apply str output \&quot;|\&quot; (apply str(for [col (get-in grid [x])]\n                                                       (if (= (col :east) 0) \&quot;    |\&quot; \&quot;     \&quot;))) \&quot;\\n\&quot;\n                            \&quot;+\&quot; (apply str (for [col (get-in grid [x])]\n                                             (if (= (col :south) 0) \&quot;----+\&quot;\&quot;    +\&quot;))) \&quot;\\n\&quot;)))))\n\n(defn pp-maze [grid]  ;Prints the maze to console\n  (println (apply str \&quot;+\&quot; (repeat (count (get-in grid [0])) \&quot;----+\&quot;)))\n  (loop [x 0]\n    (when (&lt; x (count grid))\n      (println (apply str \&quot;|\&quot; (for [col (get-in grid [x])]\n                                (if (= (col :east) 0) \&quot;    |\&quot; \&quot;     \&quot;))))\n      (println (apply str \&quot;+\&quot; (for [col (get-in grid [x])]\n                                (if (= (col :south) 0) \&quot;----+\&quot;\&quot;    +\&quot;))))\n      (recur (+ x 1)))))\n\n(defn newline-to-br [s]\n  (html [:pre (clojure.string/replace s #\&quot;\\r\\n|\\n|\\r\&quot; \&quot;&lt;br /&gt;\\n\&quot;)]))\n(newline-to-br (to-s (binary-generate-maze 5 5)))\n&quot;, :offset 3256, :ns &quot;user&quot;} {:command &quot;(defn make-a-row [columns]\n  (loop [count 0 row []]\n    (if (= columns count)\n      row\n      (recur (inc count) (conj row {:north 0 :east 0 :south 0 :west 0})))))\n\n(defn make-a-grid [rows columns]\n  (loop [count 0 grid []]\n    (if (= rows count)\n      grid\n      (recur (inc count) (conj grid (make-a-row columns))))))\n\n(defn binary-alter-cell [x y grid]\n  (cond\n    ; top row &amp; last cell do nothing\n    (and (= x 0) (= y (- (count(get-in grid [0])) 1))) grid\n    ;if top row only carve east\n    (= x 0) (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n    ;if eastern cell carve north\n    (= y (- (count(get-in grid [0])) 1)) (assoc-in (assoc-in grid [(- x 1) y :south] 1) [x y :north] 1)\n    ; not top row carve north or east\n    :else\n    (if (= 0 (rand-int 2))\n      (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n      (assoc-in (assoc-in grid [(- x 1) y :south] 1) [x y :north] 1))))\n\n(defn binary-maze-row [x y maze]\n  (loop [count 0 grid maze]\n    (if (= y count)\n      grid\n      (recur (inc count) (binary-alter-cell x count grid)))))\n\n(defn binary-maze-grid [rows columns maze]\n  (loop [count 0 grid maze]  ; loop over rows of empty grid\n    (if (= rows count)\n      grid  ;return grid\n      (recur (inc count) (binary-maze-row count columns grid))))) ;return value of maze-row is now grid\n\n(defn binary-generate-maze [rows cols]\n  ;uses empty grid and row col numbers\n  (binary-maze-grid rows cols (make-a-grid rows cols)))\n\n(defn to-s [grid]  ;Returns the maze as a string\n  (loop [x 0 output (apply str \&quot;+\&quot; (apply str(for [col (get-in grid [0])] \&quot;----+\&quot;)) \&quot;\\n\&quot;)]\n    (if (&gt;= x (count grid))\n      output\n      (recur (+ x 1) (apply str output \&quot;|\&quot; (apply str(for [col (get-in grid [x])]\n                                                       (if (= (col :east) 0) \&quot;    |\&quot; \&quot;     \&quot;))) \&quot;\\n\&quot;\n                            \&quot;+\&quot; (apply str (for [col (get-in grid [x])]\n                                             (if (= (col :south) 0) \&quot;----+\&quot;\&quot;    +\&quot;))) \&quot;\\n\&quot;)))))\n\n(defn pp-maze [grid]  ;Prints the maze to console\n  (println (apply str \&quot;+\&quot; (repeat (count (get-in grid [0])) \&quot;----+\&quot;)))\n  (loop [x 0]\n    (when (&lt; x (count grid))\n      (println (apply str \&quot;|\&quot; (for [col (get-in grid [x])]\n                                (if (= (col :east) 0) \&quot;    |\&quot; \&quot;     \&quot;))))\n      (println (apply str \&quot;+\&quot; (for [col (get-in grid [x])]\n                                (if (= (col :south) 0) \&quot;----+\&quot;\&quot;    +\&quot;))))\n      (recur (+ x 1)))))\n\n(defn to-html [s]\n  (html [:pre (clojure.string/replace s #\&quot;\\r\\n|\\n|\\r\&quot; \&quot;&lt;br /&gt;\\n\&quot;)]))&quot;, :offset 2539, :ns &quot;maze-task-2.core&quot;} {:command &quot;(to-html (to-s (binary-generate-maze 5 5)))&quot;, :offset 43, :ns &quot;maze-task-2.core&quot;} {:command &quot;(ns maze-task-2.core\n  (:require [monger.core :as mg]\n            [monger.collection :as mc]\n            [clojure.data.json :as json]\n            [compojure.core :refer :all]\n            [compojure.coercions :refer :all]\n            [compojure.route :as route]\n            [compojure.handler :refer [site]]\n            [ring.middleware.defaults :refer :all]\n            [ring.middleware.params :refer [wrap-params]]\n            [clojure.java.jdbc :as sql]\n            [stencil.core :refer [render-string]]\n            [ring.adapter.jetty :as jetty])\n  (:use [hiccup.core])\n  (:import [com.mongodb MongoOptions ServerAddress]\n           [org.bson.types ObjectId]\n           [com.mongodb DB WriteConcern]))\n\n(defn make-a-row [columns]\n  (loop [count 0 row []]\n    (if (= columns count)\n      row\n      (recur (inc count) (conj row {:north 0 :east 0 :south 0 :west 0})))))\n\n(defn make-a-grid [rows columns]\n  (loop [count 0 grid []]\n    (if (= rows count)\n      grid\n      (recur (inc count) (conj grid (make-a-row columns))))))\n\n(defn binary-alter-cell [x y grid]\n  (cond\n    ; top row &amp; last cell do nothing\n    (and (= x 0) (= y (- (count(get-in grid [0])) 1))) grid\n    ;if top row only carve east\n    (= x 0) (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n    ;if eastern cell carve north\n    (= y (- (count(get-in grid [0])) 1)) (assoc-in (assoc-in grid [(- x 1) y :south] 1) [x y :north] 1)\n    ; not top row carve north or east\n    :else\n    (if (= 0 (rand-int 2))\n      (assoc-in (assoc-in grid [x (+ y 1) :west] 1) [x y :east] 1)\n      (assoc-in (assoc-in grid [(- x 1) y :south] 1) [x y :north] 1))))\n\n(defn binary-maze-row [x y maze]\n  (loop [count 0 grid maze]\n    (if (= y count)\n      grid\n      (recur (inc count) (binary-alter-cell x count grid)))))\n\n(defn binary-maze-grid [rows columns maze]\n  (loop [count 0 grid maze]  ; loop over rows of empty grid\n    (if (= rows count)\n      grid  ;return grid\n      (recur (inc count) (binary-maze-row count columns grid))))) ;return value of maze-row is now grid\n\n(defn binary-generate-maze [rows cols]\n  ;uses empty grid and row col numbers\n  (binary-maze-grid rows cols (make-a-grid rows cols)))\n\n(defn to-s [grid]  ;Returns the maze as a string\n  (loop [x 0 output (apply str \&quot;+\&quot; (apply str(for [col (get-in grid [0])] \&quot;----+\&quot;)) \&quot;\\n\&quot;)]\n    (if (&gt;= x (count grid))\n      output\n      (recur (+ x 1) (apply str output \&quot;|\&quot; (apply str(for [col (get-in grid [x])]\n                                                       (if (= (col :east) 0) \&quot;    |\&quot; \&quot;     \&quot;))) \&quot;\\n\&quot;\n                            \&quot;+\&quot; (apply str (for [col (get-in grid [x])]\n                                             (if (= (col :south) 0) \&quot;----+\&quot;\&quot;    +\&quot;))) \&quot;\\n\&quot;)))))\n\n(defn pp-maze [grid]  ;Prints the maze to console\n  (println (apply str \&quot;+\&quot; (repeat (count (get-in grid [0])) \&quot;----+\&quot;)))\n  (loop [x 0]\n    (when (&lt; x (count grid))\n      (println (apply str \&quot;|\&quot; (for [col (get-in grid [x])]\n                                (if (= (col :east) 0) \&quot;    |\&quot; \&quot;     \&quot;))))\n      (println (apply str \&quot;+\&quot; (for [col (get-in grid [x])]\n                                (if (= (col :south) 0) \&quot;----+\&quot;\&quot;    +\&quot;))))\n      (recur (+ x 1)))))\n\n(defn to-html [s]\n  (html [:pre (clojure.string/replace s #\&quot;\\r\\n|\\n|\\r\&quot; \&quot;&lt;br /&gt;\\n\&quot;)]))\n\n(defn binary-generate-maze-json [rows cols]\n  (json/write-str (binary-generate-maze rows cols)))&quot;, :offset 3343, :ns &quot;user&quot;} {:command &quot;(json/write-str (binary-generate-maze rows cols))&quot;, :offset 49, :ns &quot;maze-task-2.core&quot;} {:command &quot;(json/write-str (binary-generate-maze 4 4))&quot;, :offset 41, :ns &quot;maze-task-2.core&quot;}], :remote []}}</component>
  <component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
  </component>
  <component name="RunManager" selected="Clojure REPL.repl">
    <configuration default="true" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <module name="maze_task_2" />
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="INTELLIJ" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false">
      <setting name="host" value="" />
      <setting name="port" value="0" />
      <setting name="replType" value="0" />
      <module name="" />
      <method v="2" />
    </configuration>
    <configuration name="repl" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <module name="maze_task_2" />
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="INTELLIJ" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <method v="2" />
    </configuration>
    <configuration name="core" type="ClojureScriptRunConfiguration" factoryName="Clojure Script" temporary="true">
      <module name="maze_task_2" />
      <setting name="path" value="$PROJECT_DIR$/src/maze_task_2/core.clj" />
      <setting name="namespace" value="" />
      <setting name="execution" value="INTELLIJ" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="vmparams" value="" />
      <setting name="params" value="" />
      <setting name="workDir" value="$PROJECT_DIR$/src/maze_task_2" />
      <method v="2" />
    </configuration>
    <configuration name="maze-task-2.core" type="ClojureScriptRunConfiguration" factoryName="Clojure Script" temporary="true">
      <module name="maze_task_2" />
      <setting name="path" value="" />
      <setting name="namespace" value="maze-task-2.core" />
      <setting name="execution" value="INTELLIJ" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="vmparams" value="" />
      <setting name="params" value="" />
      <setting name="workDir" value="$PROJECT_DIR$" />
      <method v="2" />
    </configuration>
    <list>
      <item itemvalue="Clojure Application.core" />
      <item itemvalue="Clojure Application.maze-task-2.core" />
      <item itemvalue="Clojure REPL.repl" />
    </list>
    <recent_temporary>
      <list>
        <item itemvalue="Clojure Application.maze-task-2.core" />
        <item itemvalue="Clojure Application.core" />
      </list>
    </recent_temporary>
  </component>
  <component name="SvnConfiguration">
    <configuration />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="dcda5aca-7c30-45ba-be1f-8963b381224e" name="Default Changelist" comment="" />
      <created>1581349709047</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1581349709047</updated>
      <workItem from="1581349711415" duration="1499000" />
      <workItem from="1582383384113" duration="1801000" />
      <workItem from="1583754244302" duration="18000" />
      <workItem from="1584219169407" duration="2714000" />
      <workItem from="1584265405441" duration="4094000" />
      <workItem from="1584377637814" duration="199000" />
      <workItem from="1584380670553" duration="5141000" />
      <workItem from="1584471414700" duration="9612000" />
      <workItem from="1584639632093" duration="29756000" />
      <workItem from="1584913156618" duration="7797000" />
      <workItem from="1584923691393" duration="182000" />
      <workItem from="1584923889020" duration="4046000" />
      <workItem from="1584970921838" duration="6497000" />
      <workItem from="1584984596660" duration="30069000" />
      <workItem from="1585063253253" duration="1005000" />
      <workItem from="1585064277544" duration="970000" />
    </task>
    <servers />
  </component>
  <component name="TypeScriptGeneratedFilesManager">
    <option name="version" value="1" />
  </component>
  <component name="Vcs.Log.Tabs.Properties">
    <option name="TAB_STATES">
      <map>
        <entry key="MAIN">
          <value>
            <State>
              <option name="COLUMN_ORDER" />
            </State>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>